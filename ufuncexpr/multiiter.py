import inspect
import ctypes

from pkg_resources import resource_filename

import numpy as np

import numba

from llvm import core as lc, passes as lp, LLVMException
from llvm.core import Module, Constant, Type, Function, Builder

RUNTIME_LL = resource_filename(__name__, 'runtime.ll')

class MultiIterFunc(object):
    FUNC_TYPE =  ctypes.CFUNCTYPE(ctypes.c_int)

    py_func = None

    def __init__(self, name, doc, arity):
        self.__name__ = name
        self.doc = doc
        self.arity = arity
        self.llvm_functions = ()
        self._func_map = {}
       

    @classmethod
    def decorate(cls, func):
        arity = len(inspect.getargspec(func).args)
        ob = cls(func.func_name, func.__doc__, arity)
        ob.py_func = func
        return ob


    def add_specialization(self, llvm_func):
        arg_types = tuple(_llvm_ty_to_dtype(a.type) for a in llvm_func.args)
        return_type = _llvm_ty_to_dtype(llvm_func.type.pointee.return_type)
        loop_func = multiiter_func('multiiter_'+llvm_func.name, llvm_func)
        self.llvm_functions += (loop_func,)
        ee = llvm_func.module.owner
        loop_func_addr = ee.get_pointer_to_function(loop_func)
        loop_func_ctypes = self.FUNC_TYPE(loop_func_addr)
        loop_func_ctypes.argtypes = [ctypes.py_object]
        self._func_map[arg_types] = (return_type, loop_func_ctypes)

    def _get_func_and_data_for_args(self, args):
        args =[(np.array(a) if not isinstance(a, np.ndarray) else a)
               for a in args]
        arg_types = tuple(a.dtype for a in args)
        if arg_types not in self._func_map:
            argtypes = map(_dtype_to_numba, arg_types)
            jitted = numba.jit(argtypes=argtypes)(self.py_func)
            self.add_specialization(jitted.lfunc)
        ret_type, func = self._func_map[arg_types]
        return func, args, ret_type
        #args =[(a if a.dtype==dtype else a.astype(dtype))
               #for a,dtype in zip(args, self.arg_types)]

    def __call__(self, *args, **kw):
        if not len(args)==self.arity:
            raise TypeError("%d args expected"%self.arity)
        func, args, ret_type = self._get_func_and_data_for_args(args)
        if len(args)==0:
            out_shape = ()
        else:
            out_shape = np.broadcast_arrays(*args)[0].shape
        out = np.empty(out_shape, ret_type)
        masks = [a for a in (getattr(a, 'mask', None) for a in args)
                   if a is not None]
        if masks:
            out = np.ma.MaskedArray(out, reduce(np.add, masks))

        if len(args)==0:
            # dummy arg since broadcast needs at least 2 arguments
            args = [out]

        multi = np.broadcast(*(args+[out]))
        func(multi)

        if out.ndim==0:
            out = out.tolist()
        return out
                

    def __repr__(self):
        data = self.__module__, self.__name__, self.__class__.__name__, id(self)
        return '<%s.%s %s object at 0x%x>'%data

    def __reduce__(self):
        return self.__name__


def _link_runtime_if_necessary(module):
    try:
        module.get_function_named('__PyArray_MultiIter_NEXT')
        return
    except LLVMException:
        pass

    m = Module.from_assembly(open(RUNTIME_LL))
    module.link_in(m)


_llvm_ty_str_to_numpy = {
    'i1'     : np.bool_,
    'i8'     : np.int8,
    'i8'     : np.int8,
    'i16'    : np.int16,
    'i32'    : np.int32,
    'i64'    : np.int64,
    'float'  : np.float32,
    'double' : np.float64,
}

def _llvm_ty_to_numpy(ty):
    return _llvm_ty_str_to_numpy[str(ty)]

def _llvm_ty_to_dtype(ty):
    return np.dtype(_llvm_ty_to_numpy(ty))

_numpy_to_numba = {
    np.bool_: numba.bool_,
    np.int8: numba.int8,
    np.int16: numba.int16,
    np.int32: numba.int32,
    np.int64: numba.int64,
    np.float32: numba.float32,
    np.float64: numba.double,
}

_dtype_to_numba_map = dict((np.dtype(k),v) for k,v in _numpy_to_numba.items())

def _dtype_to_numba(dtype):
    return _dtype_to_numba_map[dtype]
        
def multiiter_func(name, func, optimize=True):
    """
    Generates IR for a function of which calls `func` to compute each element
    of the sequence generated by a PyArray_MultiTer.
    The generated code looks something like the following C code.

    void
    func(PyObject *multiiter)
    {
        while (PyArray_MultiIter_NOTDONE(multiiter)) {
            *((double*)PyArray_MultiIter_DATA(multiiter, N)) = func(
                *((double*)PyArray_MultiIter_DATA(multiiter, 0)),
                *((double*)PyArray_MultiIter_DATA(multiiter, 1)),
                ...,
                *((double*)PyArray_MultiIter_DATA(multiiter, N-1)));
            PyArray_MultiIter_NEXT(multiiter);
        }
    }
    """
    module = func.module
    _link_runtime_if_necessary(module)
    n_args = len(func.args)
    ret_type = func.type.pointee.return_type
    py_obj_t = Type.pointer(module.get_type_named('struct._object'))
    func_t = Type.function(Type.void(), [py_obj_t])
    ret_func = Function.new(module, func_t, name)

    multi = ret_func.args[0]
    MultiIter_DATA = module.get_function_named('__PyArray_MultiIter_DATA')
    MultiIter_DATA.add_attribute(lc.ATTR_ALWAYS_INLINE)
    MultiIter_NOTDONE = module.get_function_named('__PyArray_MultiIter_NOTDONE')
    MultiIter_NOTDONE.add_attribute(lc.ATTR_ALWAYS_INLINE)
    MultiIter_NEXT = module.get_function_named('__PyArray_MultiIter_NEXT')
    MultiIter_NEXT.add_attribute(lc.ATTR_ALWAYS_INLINE)

    entry_block = ret_func.append_basic_block('entry')
    builder = Builder.new(entry_block)

    loop_header_block = ret_func.append_basic_block('loop-header')
    loop_body_block = ret_func.append_basic_block('loop-body')
    after_block = ret_func.append_basic_block('after')

    status_ok = Constant.int(Type.int(), 0)
    status_err = Constant.int(Type.int(), -1)

    # entry block
    builder.position_at_beginning(entry_block)
    builder.branch(loop_header_block)

    # loop-header block
    builder.position_at_end(loop_header_block)
    done = builder.call(MultiIter_NOTDONE, [multi])
    is_done = builder.icmp(lc.ICMP_EQ, done, Constant.int(Type.int(), 0))
    builder.cbranch(is_done, after_block, loop_body_block)

    # loop-body block
    builder.position_at_end(loop_body_block)
    def deref(type, idx):
        addr = builder.call(MultiIter_DATA,
                            [multi, Constant.int(Type.int(), idx)])
        addr = builder.bitcast(addr, Type.pointer(type))
        return builder.load(addr)
    args = [deref(a.type, i) for i,a in enumerate(func.args)]
    ret = builder.call(func, args)
    ret_addr = builder.bitcast(
        builder.call(MultiIter_DATA, [multi, Constant.int(Type.int(), n_args)]),
        Type.pointer(ret_type)
        )
    builder.store(ret, ret_addr)
    builder.call(MultiIter_NEXT, [multi])
    builder.branch(loop_header_block)

    # after block
    builder.position_at_end(after_block)
    builder.ret_void()

    if optimize:
        func.add_attribute(lc.ATTR_ALWAYS_INLINE)
        try:
            _optimize_func(ret_func)
        finally:
            func.remove_attribute(lc.ATTR_ALWAYS_INLINE)
    
    return ret_func

def _optimize_func(lfunc, opt_level=3):
    pmb = lp.PassManagerBuilder.new()
    pmb.opt_level = opt_level
    pmb.vectorize = True
    fpm = lp.PassManager.new()
    fpm.add(lp.PASS_ALWAYS_INLINE)
    pmb.populate(fpm)
    fpm.run(lfunc.module)
